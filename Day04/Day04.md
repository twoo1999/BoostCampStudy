# 메모리 구조

### 코드 영역

프로그래머가 작성한 코드가 저장되는 메모리입니다.

### 데이터 영역

프로그램의 전역 변수와 정적 변수가 저장되는 영역입니다.
프로그램의 시작과 동시에 할당되고, 종료되면 소멸합니다.

- #### 전역 변수

  함수의 외부에서 선언된 변수를 의미합니다.
  프로그램의 어디에서나 접근할 수 있으며 데이터 영역의 소멸과 함께 소멸합니다.

  다만 전역변수는 메모리를 차지하는 시간이 길기 때문에 자주 사용하는 것은 추천되지 않습니다.

- #### 정적 변수(static)

  정적 변수는 전역 변수와 지역 변수의 특성을 모두 가지는 변수입니다. 함수 내에서 선언하며 함수내에서만 사용 가능합니다.<br>

  아래와 같은 함수에서는 정적 변수를 사용하는 함수를 보여줍니다.<br>

  지역 변수라면 계속 cnt를 1로 초기화한 상태에서 함수가 진행되지만 static 변수는 한 번 초기화하고 계속 그 상태의 값을 함수에서 업데이트합니다.

```

int main(){
  for(int i = 0 ; i < 3; i++){
    static_func(); // 1 -> 2 -> 3
  }
  return 0;
}

void static_func(void){
  static int cnt  = 1;
  printf("%d\n", cnt);
  cnt++;
}

// 1
// 2
// 3
```

### 스택 영역

스택 영역은 함수 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다. 함수의 호출과 동시에 스택 영역에 할당되고 함수가 return하면 할당을 해제합니다.<br>

스택 영역은 자료구조의 스택과 마찬가지로 후입선출(LIFO)방식을 가지며 push를 통해 데이터를 저장하고 pop을 통해 데이터를 삭제합니다.

또한 저장되는 함수의 정보를 스택 프레임이라고 합니다.

#### 스택프레임

호출되는 함수와 관련되 데이터가 저장되는 영역입니다.<br> 즉 스택에 차례로 저장되는 함수의 호출 정보를 스택 프레임이라고 합니다.

#### 스택 오버플로우

재귀함수의 경우 혹은 함수내에서 다른 함수를 호출하는 경우에는 오버플로우에 유의해야합니다.<br>

스택에 스택프레임이 쌓이는 과정에서 제한된 스택 용량을 넘어서는 경우 프로그램이 강제 종료되는 상황이 발생합니다.

<br> 다만 저희가 하는 일반적인 프로젝트 프로그램의 경우에는 오버플로우가 발생할 상황이 드물긴합니다.<br>

저의 경우에는 아두이노를 조작하는 과정에서 메모리 문제가 자주 발생하는 경우가 있었는데 이 경우를 제외하고서는 한번도 본 적 없는 상황이긴 합니다.

### 힙

힙 영역은 사용자가 직접 관리하는 영역입니다.

간단하게 말하면 동적할당되는 데이터가 저장되는 부분입니다. 직접 관리라고 하면 어려울 수도 있지만 코드 상에서 제가 직접 할당하는 데이터다라는 개념으로 접근하면 좋을 것 같습니다.
malloc, new등이 이에 속합니다.

사용자가 관리한다는 것은 생성부터 삭제까지 사용자가 해야한다는 것과 같습니다.

c에서는 malloc을 통해 동적 할당한 변수가 있다면 free를 통해 삭제하는 과정을 거쳐야합니다.

생성만 하고 삭제를 안한다면 이 또한 오버플로우로 이어질 수 있습니다.

다만 자바, 자바스크립트 등의 언어에서는 자동으로 삭제하는 기능이 있습니다. 이에 대해서는 후술하겠습니다.

[참고] http://www.tcpschool.com/c/c_memory_structure

# Node.js의 메모리 구조

위의 메모리 구조는 가장 기본적인 C를 기준으로 서술했습니다. <br>저수준의 언어인 C와 달리 JS의 V8 엔진은 힙의 메모리를 시스템 상에서 자동으로 관리해주는 기능 등 사용자 친화적인 시스템을 지닌다고 보면 될거같습니다.

### V8 엔진

V8 엔진이란 Google에서 만든 js 컴파일러로 C++기반으로 만들어진 오픈소스입니다.<br>

### V8 엔진의 메모리 구조

![메모리구조](https://github.com/twoo1999/BoostCampStudy/assets/125804293/8342796d-5736-415d-88b7-82483298f112)

- Resident Set:<br>
  V8 엔진으로 프로그램을 실행하면 메모리에 빈 공간을 할당하게 되는데 이 공간을 Resident Set이라고 합니다.

- stack, heap<br>
  위의 내용과 유사합니다.

- New space 와 Old space
  New space 와 Old space는 힙에 저장되는 데이터가 저장되는 곳 입니다.
  <br> 다만 이렇게 구분한 이유를 설명하자면 위에서 설명했듯이 자동으로 메모리를 관리해주는 기능을 위해서입니다.

- 마이너 GC(Garbage Collection) 또는 스캐빈저 과정
  ![슬라이드1](https://github.com/twoo1999/BoostCampStudy/assets/125804293/9c756221-22ee-4278-93cd-12d248f6c57e)

1. 우선 먼저 저장되는 데이터는 처음 New Space의 semi-space(to)에 저장됩니다.
   ![슬라이드2](https://github.com/twoo1999/BoostCampStudy/assets/125804293/e0c305d5-025c-40e4-a9c5-298289c7ca45)

2. semi-space(to)도 메모리이기에 한정된 용량을 넘어선다면 모든 데이터가 semi-space(from)으로 이동합니다.
   ![슬라이드3](https://github.com/twoo1999/BoostCampStudy/assets/125804293/d36beaca-5777-450b-8105-64c4fc16ad07)

3. semi-space(from)에 있는 데이터 중 메모리를 사용하는 데이터는 다시 semi-space(to)로 이동하고 나머지 데이터(semi-space(from)에 있는 데이터)는 삭제됩니다.
   ![슬라이드4](https://github.com/twoo1999/BoostCampStudy/assets/125804293/9a489efa-a3f3-460c-ac00-a8a3ff48cc62)

4. 이제 또 다시 새로운 데이터가 추가됐다고 가정합시다.
   ![슬라이드5](https://github.com/twoo1999/BoostCampStudy/assets/125804293/4884a158-1d34-4b3d-bebc-2346201dd751)

5. 위의 과정과 똑같이 semi-space(to)가 가득 차게된다면 모든 데이터가 semi-space(from)으로 이동합니다.
   ![슬라이드6](https://github.com/twoo1999/BoostCampStudy/assets/125804293/8354e18d-3e2e-478e-8b72-60fe7dd88286)

6. 이 과정에서 메모리를 사용하는 데이터는 다시 이동을 하게 되는데 이 때 두가지로 나뉩니다. 첫번째는 기존에 먼저 처리가 된 데이터(A, B, C) 두번째는 처음 처리되는 데이터(F, G) A, B, C 메모리를 사용하고 있는 데이터는 Old 영역으로 들어가게 되고 F, G는 다시 semi-space(to)로 들어가게 됩니다.
   <br> 즉 두번의 처리를 거치고 살아남은 데이터는 Old 영역으로 넘어가게 됩니다.
   ![슬라이드7](https://github.com/twoo1999/BoostCampStudy/assets/125804293/d19e2bdd-653c-48da-adb0-f8adedd807fa)

7. 이에 따른 최종 상태입니다.
   ![슬라이드8](https://github.com/twoo1999/BoostCampStudy/assets/125804293/c83fb4c5-234b-44ef-bf94-44a04944ff8a)
   이때 Old Pointer 영역과 Old Data영역이 있는데 이 구분은 간단합니다.
   실제 데이터를 참조하는 포인터이냐 실제 데이터냐의 차이입니다.
   모든 객체는 Old Pointer이고 문자열의 경우에는 Old Data라고 볼 수 있습니다.

- 메이저 GC
  마이너 GC는 New Space를 관리하는 기능입니다. 이에 따라 New Space는 관리할 수 있지만 Old Space는 관리할 수 없습니다.

  당연하겠지만 Old Space 또한 메모리이기에 가득 차는 상황이 발생할 수 있습니다. 이 상황을 방지하는 것이 메이저 GC 입니다. 기본적인 이념은 마이너 GC와 비슷합니다.

1. 모든 데이터를 DFS하며 탐색합니다.
2. 탐색한 데이터는 메모리를 사용하고 있는 데이터의 경우 마킹을 합니다. (당연하겠지만 메모리를 사용하지 않는 데이터의 경우 마킹이 되지 않습니다.)
3. 마킹되지 않는 데이터는 제거함으로써 Old Space를 유지관리합니다.

지금까지의 과정이 Node.js에서 메모리 누수를 방지하기 위해 관리하는 방법입니다. <br> 지금까지 C를 많이 해서 이에 익숙했는데 V8을 알고나니 시스템이 얼마나 고마운지 모르겠네요...

- 나머지 영역 : <br>
  종류에 맞게 저장해서 편하게 하기 위한 영역이라고 보면 되겠습니다.
  ]

[참고]https://ui.toast.com/weekly-pick/ko_20200228<br>
[참고]https://m.blog.naver.com/dlaxodud2388/222307876737

# 리눅스 운영체제의 가상메모리

### 가상메모리:

물리메모리의 크기가 제한적인 한계를 극복하기 위해 도입된 방법입니다.

가상주소와 물리적 주소를 구분함으로써 실제 메모리의 크기를 논리적으로 확장할 수 있습니다.

### 가상 주소

하나의 프로그램 당 주소를 가집니다. 근데 이 주소는 중복될 수도 있습니다.

두개의 프로그램이 있다고 가정했을 때 두개의 프로그램 각각의 주소가 같을 수 있다는 것입니다.

그렇다면 CPU가 이를 구분할 수 있도록 해줘야 프로그램이 정상 작동할 것입니다.

그래서 이 주소에 하나의 값을 더함으로써 독립적인 주소를 만들어냅니다.

즉 더하기 전 주소가 가상주소(논리주소)이고 더한 후의 주소가 물리주소가 됩니다.

### MMU :

실제 가상 주소를 논리 주소로 변환하는 하드웨어 입니다.

위에서 언급한 가상주소를 물리주소로 변환하는 과정이 필요합니다.

굳이 값을 더해서 물리주소로 만들었는데 또 가상주소를 물리주소로 변환해야하는 이유가 있습니다.

바로 CPU는 가상주소만을 읽을 수 있기 때문입니다. 그래서 이 가상주소를 물리주소로 바꾸는 과정이 하나 더 필요한 것 입니다.

![MMU](https://github.com/twoo1999/BoostCampStudy/assets/125804293/f694bd0b-cf45-4821-b23f-ed306dae9fe1)

### swapping 기법

우리가 당장 필요한 데이터는 메인메모리에 저장되어 있어야 가져와서 사용할 수 있습니다.<br>

다만 메모리는 한정된 공간을 갖기에 모든 데이터를 메인메모리에 저장할 수 없습니다.
<br>

그래서 리눅스에서는 하드디스크를 이용해 메모리를 확장합니다. 지금 당장 사용하지 않는 데이터는 하드디스크에 저장하고 필요한 데이터만을 메인메모리에 적재하는 방식으로 메모리를 관리합니다.

<br>
이 과정에서 하드디스크에서 데이터를 가져오고 다시 하드디스크에 데이터를 넣는 모습이 보여 Swapping기법이라고 합니다.

![swap](https://github.com/twoo1999/BoostCampStudy/assets/125804293/f9452a54-c834-41fa-a3cc-deb7a93682fa)

### 페이징 기법

Swap 영역에 저장된 데이터는 페이지(미리 정의된 크기)로 나눕니다.

구분된 페이지 중 현재 프로세스에서 필요한 페이지만을 메인메모리에 적재함으로써 보다 효율적으로 메모리를 관리할 수 있습니다.

### 페이지 테이블

그러나 페이지를 넣고 빼고를 반복하면 페이지가 연속성이 없어지고 구조가 한층 더 복잡해집니다.

이를 해결하기 위해 메모리에 페이지 테이블을 구성합니다.

페이지 테이블을 통해 복잡하기 않게 페이지에 접근할 수 있습니다.

### TLB

페이지 테이블이 크기가 큰 편입니다. 이를 메모리에 저장하고 있는데 그 크기가 상당하다 보니 효율적인 메모리 관리를 위해 여러가지 기능을 더 추가합니다.

그 중 하나가 TLB입니다. 간단하게 말하면 캐시같다 라고 보면 되겠습니다.

CPU는 MMU를 통해 주소를 변경하기 전 TLB에 먼저 접근합니다.

TLB에 저장된 정보라면 메모리에 바로 접근해서 데이터를 가져옵니다.

근데 TLB에 저장되지 않은 정보라면 페이지 테이블을 참고해서 데이터를 가져옵니다.

차이는 메모리에 한번 접근하냐 두번 접근하냐의 차이가 되겠습니다.

[참고]<br>
https://jeongzero.oopy.io/359eaa11-b6e6-466c-a066-9ae582c886d4<br>
https://parkadd.tistory.com/121
