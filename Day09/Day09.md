# 프로세스와 프로그램

프로그램은 디스크에 저장되어 있습니다. 이 프로그램이 메모리에 적재됐을 때 즉, 프로그램을 실행하기 위한 준비를 하고 실행을 할 때 프로그램은 비로소 프로세스가 되는 것 입니다.

즉 프로세스는 실행중인 프로그램이라고 할 수 있습니다.

### PCB의 구성

후술할 스케줄링을 위해 프로세스의 정보를 저장하고 있어야 하는데 이 저장 자료구조를 PCB라고 합니다.

PCB는 아래와 같은 정보를 저장하고 있습니다.

`프로세스 식별자(PID)`

운영체제가 각 프로세스를 구분하기 위한 고유한 번호입니다.

`프로세스 상태(Process State)`

생성, 준비, 실행, 대기, 완료의 상태가 있습니다.

`PC(Program Counter)`

실행할 명령어의 위치입니다.

CPU는 명령어를 하나씩 인출하여 실행하는 사이클을 가집니다.

이러한 상황에서 다음에 실행할 명령어를 가르키게 됩니다.

`CPU 레지스터`

누산기, 레지스터 및 범용 레지스터 등 CPU가 가지는 레지스터의 정보를 저장합니다.

`CPU 스케줄링 정보`

우선 순위, 최종 실행시각, CPU 점유시간 등이 포함됩니다.

`포인터`

프로세스의 현재 위치를 저장하는 포인터 정보입니다.

### 문맥 교환(Context Switch)

![Alt text](<이미지/Context Switch.png>)<br>
[이미지출처] https://www.tutorialandexample.com/what-is-context-switching

문맥은 프로세스의 상태 정보를 의미합니다.

문맥 교환이란 스케줄링을 위해 프로세스의 상태 정보를 교환하는 작업을 말합니다.

문맥교환이 일어나면 기존에 실행중이던 프로세스는 현재의 상태를 자신의 PCB에 저장하고 다음으로 실행하고자 하는 프로세스의 PCB를 읽어 CPU의 레지스터에 적재하는 동작이 일어납니다.

문맥교환이 일어나는 과정에서는 다른 어떠한 동작을 할 수 없어 오버헤드라고 말합니다.

스케줄링을 CPU의 효율성을 위한 작업이긴하지만 너무 자주 일어나게 되면 오히려 효율성을 해치는 작업이 될 수 있으니 주의하도록 합니다.

### 프로세스 상태

위의 그림은 2개의 프로세스가 문맥교환이 일어나는 과정이었습니다.

이제는 더 많은 프로세스가 있다고 보고 프로세스의 상태를 적겠습니다.

![Alt text](%EC%9D%B4%EB%AF%B8%EC%A7%80/processState.drawio.png)

`생성` : 프로세스가 막 생성된 상태입니다.

`준비` : 프로세스가 실행되기 위해 대기하고 있는 상태입니다. 준비단계에서는 준비 큐가 존재하고 실행으로 상태 전이하기 위해 기다리고 있는 프로세스가 모여있습니다.

`실행` : 프로세스가 실행되고 있는 상태입니다.

`대기` : I/O 입력이 필요하거나 특정 이벤트가 발생했을 때의 상태입니다. I/O입력이 완료되거나 이벤트가 끝났을 때 실행을 준비상태로 돌아갈 수 있습니다. 준비와 마찬가지고 대기하고 있는 프로세스를 모아둔 대기 큐가 존재합니다.

`완료` : 프로세스의 동작이 완료된 상태입니다.

`디스패치` : 준비 큐에 저장된 프로세스를 실행으로 상태전이합니다.

`시간종료` : 하나의 프로세스가 너무 많은 시간동안 CPU를 점유하지 못하도록 제어권을 뺏는 상황입니다.

### 스케줄러

- 장기 스케줄러(작업 스케줄러)

생성->준비(admit), 실행->종료(Release)와 관련된 스케줄링입니다.

디스크에 있는 프로그램 중 어떤 프로그램을 메모리에 적재사고 이를 준비큐에 삽입할지 결정하는 역할입니다.

다른 스케줄링에 비해 빈도수가 높지않아 시간이 오래걸려도 상관없습니다.

하지만 현대들어서는 사용하지 않는 시스템이 많아졌다고 합니다.

- 단기 스케줄러(CPU 스케줄러)

준비 큐에 있는 준비 상태의 프로세스 중 어떤 프로세스를 실행 상태로 상태 전이를 할지 결정합니다.

시간 종료(Time Out)이 발생(타이머 인터럽트)가 발생하면 단기 스케줄러가 호출됩니다.

단기 스케줄러는 다른 스케줄러에 비해 자주 일어나기 때문에 걸리는 시간이 매우 빨라야합니다.

- 중기 스케줄러

너무 많은 프로세스가 메모리에 적재되면 당장 실행에 필요한 프로세스를 위한 메모리 공간이 없을 수도 있고 이는 성능의 저하를 불러일으킵니다.

이러한 상황에서 메모리에 있는 프로세스 중 일부를 디스크에 저장(스왑 아웃)하는 행위를 하고 다시 메모리가 여유로워지면 메모리에 적재(스왑 인)하는 동작을 합니다.

즉 프로세스를 CPU에 직접 할당하는 것이 아닌 프로세스가 CPU를 할당받을 수 있는 상황를 만들어주는 일을 합니다.

### 스케줄링

흔히 말하는 스케줄링은 위에서 말한 단기 스케줄러에 해당합니다.

CPU자원을 효율적으로 사용하기 위해 순서를 정하는 작업입니다.

### 선점 스케줄링

우선 순위가 더 높은 프로세스가 이미 점유되어 있는 CPU 제어권을 빼앗아 자신에게 할당할 수 있습니다.

빠른 응답을 원하는 시스템에서 사용합니다.

다만 너무 많은 선점은 오버헤드를 많이 발생시켜 오히려 시스템의 성능의 저하를 불러일으킬 수 있습니다.

- SRT(Shortest Remaining Time)스케줄링
  - 남은 처리 시간을 기준으로 스케줄링합니다.
  - 짧은 남은 처리 시간을 가지는 프로세스가 더 높은 우선 순위를 얻습니다.
  - 장점: 평균 대기 시간과 대기 응답 시간이 짧습니다.
  - 단점:실행 시간을 추정하는 작업이 필요합니다.
- 라운드로빈(Round Robin)스케줄링
  - 각각의 프로세스는 동일한 시간을 할당받습니다.
  - 선입선출에 의해 결정됩니다.
  - 장점 : 응답시간이 짧습니다.
  - 단점 : 시간조작이 긴 경우 콘보이 효과가 발생할 수 있습니다.(중요한 프로세스가 CPU를 할당받지 못함)
- 다단계 큐 스케줄링
  - 준비 큐를 여러개 사용합니다.
  - 각각의 큐는 독자적인 스케줄링 알고리즘을 수행하고, 큐들 사이에서도 우선순위를 정합니다.
  - 장점 : 큐들 간의 프로세스 이동이 불가하여 부담이 적습니다.
  - 단점 : 유연성이 떨어집니다.
  - 단점 : 기아현상이 발생할 수 있습니다.
- 다단계 피드백 큐 스케줄링
  - 다단계 큐 스케줄링과 같습니다.
  - 다른점은 프로세스가 큐 사이를 이동할 수 있습니다.

### 비선점 스케줄링

이미 CPU가 다른 프로세스에 할당됐다면 뺏을 수 없습니다.

응답 시간이 예측 가능합니다.

일괄 처리 방식에 적합합니다.

- HRN(Highest Response ratio Next) 스케줄링
  - 수행시간의 길이와 대기 시간의 길이를 고려합니다.
  - (대기시간+실행시간) / 실행시간 = 응답시간
  - 응답시간에 커질 수록 우선순위가 높아집니다.
- SJF(Shortest Job First) 스케줄링
  - 큐안에 있는 프로세스 중 수행시간이 짧은 것을 먼저 수행합니다.
  - 평균 대기 시간과 대기 응답 시간이 짧습니다.
  - 프로세스의 기아현상(CPU를 점유하지못함)이 발생할 수도 있습브니다.
- 우선 순위 스케줄링
  - 프로세스는 각각 우선 순위가 배정됩니다.
  - 시스템의 응답속도를 증가시킵니다.
  - 동적으로 할당할 경우 많은 오버헤드가 발생합니다.
- 기한부 스케줄링
  - 작업을 정한 시간안에 완료하도록 합니다.
  - 실행 시간이 정한 시간(Deadline)을 넘는다며면 강제 종료합니다.
- FIFO 스케줄링
  - 준비 큐에 도착한 프로세스 순으로 실행됩니다.
  - 장점 : 작업 시간을 예측하기 쉽습니다.
  - 단점 : 콘보이효과(중요한 작업이 많은 시간을 기다릴 수 있습니다.)

# 스레드

경량 프로세스라고도 불립니다. 프로세스에세 실행 제어만 분리해서 처리하는 단위를 말합니다.

같은 그룹의 쓰레드면 코드, 메모리 주소 공간, 운영체제 리소를 공유합니다.

### 자원 공유 문제

멀티 스레드 시스템에서는 스레드간 공통된 자원을 사용합니다.

이 과정에서 서로의 정보가 뒤엉키는 일이 생길 수도 있는데 이를 경쟁 상황(race condition)이라고 합니다.

### 임계영역(Critical Section)

여러 스레드들이 접근하는 코드부분을 임계영역이라고 합니다.

### 해결방법

- 뮤텍스(Mutex)

  - 하나의 프로세스 혹은 스레드가 접근하는 것을 막아줍니다.
  - 한 프로세스는 key를 기반으로 해서 임계영역에 접근할 수 있습니다.
  - key가 없으면 프로세스는 임계영역에 접근할 수 없습니다.
  - 한마디로 한 번에 하나의 프로세스만 접근할 수 있도록 한 방법입니다,

- 세마포어

  - 여러 프로세스 혹은 스레드가 접근하는 것을 막아줍니다.
  - 동기화 대상이 하나 이상의 경우
  - P, V를사용해 하나의 값을 갱신합니다.
  - 값이 +면 기다리고 있는 스레드가 없다는 뜻이고 -면 기다리고 있는 스레드가 있다라는 뜻입니다.

- 차이점
  - 뮤텍스는 동기화 대상이 하나일 때 사용하며 세마포어는 하나 이상일 때 사용합니다.
  - 뮤텍스는 자원을 소유할 수 있고 책임을 가지지만, 세마포어는 자원 소유가 불가능합니다.
  - 뮤텍스는 0, 1의 상태만 가지기에 key을 소지할 수 있고 소유하고 있는 스레드만이 뮤텍스를 해제할 수 있는 반면 세마포어는 소유하지 않는 스레드가 해제할 수 있습니다.
  - 세마포어는 시스템 범위에 걸쳐있고, 파일 시스템 상의 파일로 존재하는 반면, 뮤텍스는 프로세스의 범위를 가지며 프로세스가 종료될 때 자동으로 삭제됩니다.

### 병렬처리와 스레드

- 병렬 처리 :
  동시간에 두개 이상의 동작이 처리되는 것
- 스레드 :
  context switch을 통해 동시성을 만족하는 것

동시성과 병렬처리의 관계는 살짝 다릅니다.

동시성은 하나의 작업이 끝나진 않았지만 다른 작업을 실행해서 동시에 하는 것을 만족시킵니다.

이렇게만 들으면 스레드도 동시성을 만족시키고 병렬성도 병렬성도 동시성을 만족하니 스레드는 곧 병렬처리인가? 라는 생각이 듭니다. 멀티 코어에서는 만족하겠지만 위의 내용은 싱글 코어를 예로 들었으니 싱글 코어의 관점에서 설명하자면 살짝 다릅니다.

동시성은 동시에 동작한다는 것이지만 이는 물리적으로 같은 시간에 동작한다는 것이 아닙니다.

그래서 스레드에 배울 때 context switch을 배웠습니다.

context switch는 동시에 동작할 수 있도록 CPU의 점유를 번갈아가며 사용하는 것을 말하는 것이죠. 즉 스위칭을 빨리해서 우리가 봤을 땐 동시에 동작한다고 느낄 수 있지만 엄격히 말하면 물리적으로 동일한 시각에 동작하는 것은 아닙니다. 즉 동시성은 만족하지만 동시에 동작하는 것은 아니죠.

병렬 처리는 멀티 코어 시스템에서 물리적으로 같은 시간에 여러 동작을 수행하는 것입니다. 진짜로 물리적으로 동일한 시간에 처리를 하는 것이죠. 물론 동시성이 만족하고요.

그러니 병렬처리는 동시성을 만족하지만 모든 동시성을 만족하는 것이 병렬성도 만족시키냐? 라면 그건 아니라는 것이죠.

하지만 멀티코어시스템에서는 스레드를 통해 병렬처리가 가능합니다.

그리고 스레드에서 나왔던 공유자원의 문제 또한 병렬처리에서 발생하며 이를 동기화해주는 방법이 필요한데 이 또한 뮤텍스, 세마포어 등으로 처리합니다.
[참고]

https://vagabond95.me/posts/concurrency_vs_parallelism/

https://velog.io/@honeyoung_0117/%EB%B3%91%EB%A0%AC%EC%B2%98%EB%A6%AC

### 스레드 풀

스레드를 많이 만들어 사용하면 이론적으로는 성능이 좋아지는 것이 사실입니다. 하지만 CPU의 성능이 무한하지 않는 상태에서 무작정 많은 스레드를 생성하면 오히려 성능 저하로 이어질 수 있습니다.

스레드가 많아지면 결국 CPU의 부하가 심해집니다. 또한 스레드를 만드는 과정에서 오버헤드가 발생해 많이 만드는 것 또한 좋지 못한 일입니다.

그래서 스레드 풀을 사용합니다.

스레드는 정해진 수만큼 생성하고 작업 큐라는 것을 만들어 작업을 저장합니다.

스레드는 직접 작업을 할당받는 것이 아닌 작업 큐의 작업을 하나씩 가져와 실행하기 때문에 CPU가 받는 부하가 적어집니다.

따라서 작업이 많아져도 작업 큐에 작업이 쌓일 뿐 CPU가 받는 부담은 일정하게 되고 스레드를 많이 안 만들어 오버헤드 또한 줄어들게 되는 것이죠.

다만 단점 또한 존재합니다.

너무 많은 작업은 메모리의 낭비를 발생시킬 수 있습니다.

또한 너무 많은 스레드의 생성 또한 메모리의 낭비로 이어질 수 있습니다. 그러니 적절한 타협을 통해 가장 최상의 퍼포먼스를 보일 수 있도록 하는 것이 중요하겠습니다.

[참고]

https://steady-coding.tistory.com/548

### worker

- 하나의 프로세스
- 여러개의 스레드
- 스레드 별 하나의 이벤트 루프
- 스레드 별 하나의 js 엔진 인스턴스
- 스레드 별 하나의 node.js 인스턴스

### worker 사용법

- isMainThread : 하나의 파일 내에서 사용하고 싶다면 이걸 사용해서 메인쓰레드와 워커쓰레드를 구분합니다.

- Worker.postMessage : 워커쓰레드에 메세지를 보냅니다.

- Worker.on('message', val=>{}) : 워커쓰레드로부터 메세지를 받습니다.(리슨상태)

- Worker.on('exit',val=>{}) : 워커쓰레드가 종료됐을 시 발생

- parentPort.postMessage : 메인쓰레드로부터 메세지를 받습니다.(리슨상태)

- parentPort.on : 메인쓰레드에 메세지를 보냅니다.

- MessageChannel : worker간 데이터 송수신을 합니다.

- WorkerData : startup 데이터를 전달하기 위해 사용합니다.(초기값)

https://inpa.tistory.com/entry/NODE-%F0%9F%93%9A-workerthreads-%EB%AA%A8%EB%93%88

### 메모리 구조

프로그램은 기본적으로 메모리에 그에 대한 명령어와 데이터가 올라와있어야 실행이 가능합니다.

#### 폰 노이만 구조

프로그램 실행에 필요한 프로그램과 데이터가 한 공간에 저장됩니다.

즉 하나의 버스(데이터 이동통로)를 통해 전송합니다.

이러한 이유로 CPU가 명령어와 데이터를 한번에 하나씩만 처리 가능합니다.

#### 하버드 구조

프로그램 실행에 필요한 데이터와 프로그램이 분리된 메모리 공간에 저장됩니다.

즉 두개의 버스(데이터 이동통로)를 통해 전송합니다.

분리된 저장공간이라 폰 노이만 구조와 다른게 명령어를 가져오는 것과 데이터를 가져오는 것을 동시에 할 수 있습니다.

현대에서는 CPU 외부적으로는 폰 노이만 구조를 가지고, 내부적으로는 하버드 구조를 가집니다.

https://velog.io/@mooh2jj/%ED%8F%B0-%EB%85%B8%EC%9D%B4%EB%A7%8C-%EA%B5%AC%EC%A1%B0-vs-%ED%95%98%EB%B2%84%EB%93%9C-%EA%B5%AC%EC%A1%B0
