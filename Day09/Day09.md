### 프로세스

CPU가 처리하는 일(TASK)입니다. 즉 실행중인 프로그램을 뜻 합니다.

더 자세하게는 디스크에 저장된 프로그램이 CPU가 실행하기 위해 메모리에 적재된 프로그램을 프로세스라고 합니다.

### 메모리 구조

프로그램은 기본적으로 메모리에 그에 대한 명령어와 데이터가 올라와있어야 실행이 가능합니다.

#### 폰 노이만 구조

프로그램 실행에 필요한 프로그램과 데이터가 한 공간에 저장됩니다.

즉 하나의 버스(데이터 이동통로)를 통해 전송합니다.

이러한 이유로 CPU가 명령어와 데이터를 한번에 하나씩만 처리 가능합니다.

#### 하버드 구조

프로그램 실행에 필요한 데이터와 프로그램이 분리된 메모리 공간에 저장됩니다.

즉 두개의 버스(데이터 이동통로)를 통해 전송합니다.

분리된 저장공간이라 폰 노이만 구조와 다른게 명령어를 가져오는 것과 데이터를 가져오는 것을 동시에 할 수 있습니다.

현대에서는 CPU 외부적으로는 폰 노이만 구조를 가지고, 내부적으로는 하버드 구조를 가집니다.

https://velog.io/@mooh2jj/%ED%8F%B0-%EB%85%B8%EC%9D%B4%EB%A7%8C-%EA%B5%AC%EC%A1%B0-vs-%ED%95%98%EB%B2%84%EB%93%9C-%EA%B5%AC%EC%A1%B0

### 스케줄링

여러 프로세스(일)가 번갈아가며 사용하는 자원을 어떤 시점에 어떤 프로세스에게 할당할지 결정하는 것입니다.

좋은 스케쥴링은 프로세서의 효율성을 높이고 작업 처리 능력을 향상시킵니다.

https://www.crocus.co.kr/1373

#### 선점 스케줄링

하나의 프로세스가 CPU를 점유하고 있는 상황에서 우선순위가 더 높은 프로세스가 자원을 뺏을 수 있는 스케줄링 기법입니다.

1. 기한부 스케줄링

   - 작업이 주어진 시간이나 Deadline안에 완료되도록 하는 기법입니다.

2. 우선순위 스케줄링
   - 각 작업마다 우선 순위가 주어집니다.
   - 우선순위는 고정일 수 있고 가변적일 수도 있습니다.

#### 비선점 스케줄링

이미 할당된 CPU를 다른 프로세스가 뺏을 수 없습니다.

1. FIFO 스케줄링
   - 프로세스가 생성된 순서대로 대기큐에 넣고 순서대로 스케줄링합니다.
2. SJF 스케줄링
   - 동작시간이 가장 짧은 프로세스부터 시작합니다.
3. 라운드로빈 스케줄링
   - FIFO 스케줄링처럼 동작합니다.
   - 다른 점은 CPU의 시간에 섹터를 구분하고 섹터를 넘어갈 때까지 작업이 완료되지 못한다면 다음 차례의 프로세스로 제어가 넘어갑니다.

https://www.uname.in/252

### 스레드

경량 프로세스라고도 불립니다. 프로세스에세 실행 제어만 분리해서 처리하는 단위를 말합니다.

같은 그룹의 쓰레드면 코드, 메모리 주소 공간, 운영체제 리소를 공유합니다.

### worker

- 하나의 프로세스
- 여러개의 스레드
- 스레드 별 하나의 이벤트 루프
- 스레드 별 하나의 js 엔진 인스턴스
- 스레드 별 하나의 node.js 인스턴스

### worker 사용법

- isMainThread : 하나의 파일 내에서 사용하고 싶다면 이걸 사용해서 메인쓰레드와 워커쓰레드를 구분합니다.

- Worker.postMessage : 워커쓰레드에 메세지를 보냅니다.

- Worker.on('message', val=>{}) : 워커쓰레드로부터 메세지를 받습니다.(리슨상태)

- Worker.on('exit',val=>{}) : 워커쓰레드가 종료됐을 시 발생

- parentPort.postMessage : 메인쓰레드로부터 메세지를 받습니다.(리슨상태)

- parentPort.on : 메인쓰레드에 메세지를 보냅니다.

- MessageChannel : worker간 데이터 송수신을 합니다.

- WorkerData : startup 데이터를 전달하기 위해 사용합니다.(초기값)

https://inpa.tistory.com/entry/NODE-%F0%9F%93%9A-workerthreads-%EB%AA%A8%EB%93%88
