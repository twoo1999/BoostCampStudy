# 컴파일러

### 컴파일러란?

사람이 작성한 코드를 컴퓨터가 이해할 수 있는 기계어 코드롤 변환해주는 시스템입니다.

### 컴파일 언어

컴파일러로 빌드 과정을 거쳐 생성된 파일이 컴파일 결과입니다.

여기서 빌드란 소스코드 파일을 실행파일로 생성하는 과정입니다.
즉 사람의 코드를 변환하여 기계어로 만들고 이를 실행파일로 만드는 과정입니다.

컴파일언어는 이미 만들어진 기계어 파일을 실행하는 것이라 속도가 빠릅니다.

대표적인 예로는 C, C++, C#, Java등이 있습니다.

### 인터프리터 언어

간단하게 말하자면 컴파일언어와 다르게 사용자의 코드를 기계어로 변환하지 않고, 한줄을 읽어들이면서 바로 명령어를 실행하도록 하는 언어입니다.

대표적으로는 Python, JavaScript 등이 있습니다.

[참고]https://gobae.tistory.com/93

### 구문분석

컴파일러의 동작과정에서는 구문분석->최적화->코드생성->링킹 과정이 있습니다.

이 중 구문분석에대해서 설명하겠습니다.

### tokenizer

토큰이란 어휘 분석의 단위입니다. tokenizer는 토큰을 단위로 쪼개갰다는 말입니다. 말은 어렵지만 간단합니다

home이라는 단어가 있을 때 h, o, m, e 각각의 단어들은 따로 있을 때 의미가 없고 비로소 home으로 있을 때 의미가 생깁니다.

그래서 i go home 이라는 문장을 tokenizer를 통해 토큰화시킨다면

i, go, home이 되겠습니다.

### lexer

lexer 는 tokenizer를 통해 만들어진 토큰들에 각각의 의미를 부여하는 과정이 되겠습니다.

i, go, home의 토큰들이 있다면

i : 주어<br>
go : 동사<br>
home : 목적어<br>
이 되겠습니다.

이를 프로그래밍에 맞게 표현해보겠습니다.

let a = 2 라는 코드가 있을 때
tokenizer를 통해 <br>let, a, =, 2, ; <br>로 토큰화시킬 수 있습니다.

이를 lexer를 통해

type : letCommand, token : let<br>
type : variable, tolen : a<br>
type : equal, token : =<br>
type : integer, token : 2<br>
type : semicolon, token : ;<br>

로 의미를 부여할 수 있습니다.

### AST(Abstact Syntax Tree, 추상 구문 트리)

추상적이라는 표현은 실제 구문에서 나타나는 모든 세세한 정보를 표현하지 않는다는 것을 의미합니다.

즉 괄호 등의 자세한 내용들은 생략하고 의미를 알 수 있는 최소한의 정보로 트리를 만들어서 추상 구문 트리라는 이름이 붙혀집니다.

### parser

위의 과정을 거친 데이터를 구조적으로 나타냅니다.

# 정규표현식

정규 표현식이란 특정한 규칙을 가지는 문자열의 집합을 표현하는 데 사용하는 형식 언어입니다. 코드에서 사용한다면 특정 규칙을 가지는 문자열을 처리하는 데 사용하곤 합니다.

### 구성

/패턴/플래그 형식으로 구성합니다.

### 메서드

match : 문자열에서 정규표현식에 해당하는 부분들을 배열로 리턴<br>

replace : 문자열에서 정규표현식에 해당하는 부분을 대체<br>

split : 문자열에서 정규표현식에 해당하는 구분자로 쪼갬<br>

test : 문자열이 정규표현식에 해당하는 부분이 있으면 true 아니면 false로 반환<br>

exec : match와 동일 (단, 첫번째 결과만 반환)

### 플래그

i(ignore Case) : 대소문자를 가리지 않고 검색<br>

g(Global) : 문자열 내의 모든 패턴을 검색<br>

m(multi Line) : 문자열의 행이 바뀌더라도 검색을 계속<br>

s : 모든 문자 정규식이 개행 문자 \n도 포함하도록 설정<br>

u(unicode) : 유니코드 전체를 지원<br>

y(sticky) : 문자 내 특정 위치에서 검색을 진행하는 sticky모드를 활성화<br>

# 기호(가장 많이 쓰는 것 위주)

a-zA-Z 영어알파벳(-으로 범위 지정)<br>

ㄱ-ㅎ가-힣 한글 문자(-으로 범위 지정)<br>

0-9 숫자(-으로 범위 지정)<br>

\d 숫자<br>

\D 숫자가 아닌 것<br>

\w 밑줄 문자를 포함한 영숫자 문자에 대응<[A-Za-z0-9_] 와 동일<br>

\W \w 가 아닌 것<br>

\s space 공백<br>

\S space 공백이 아닌 것<br>

\특수기호 특수기호 \* \^ \& \! \? ...등

### 정규식 검색 기준 패턴

| : or

[] : 괄호안의 문자 중 하나

[^문자] : 괄호안의 문자 제외

^문자열 : 문자열로 시작

문자열$ : 문자열로 끝남

### 정규식 갯수 반복 패턴

? : 없거나 or 최대 한개만

\- : 없거나 or 있거나 (여러개)

\* : 최소 한개 or 여러개

\*? : 없거나, 있거나 and 없거나, 최대한개 : 없음

+? : 최소한개, 있거나 and 없거나, 최대한개 : 한개

{n} : n개

{Min,} : 최소 Min개 이상

{Min, Max} : 최소 Min개 이상, 최대 Max개 이하

코드 상에서 이를 바꿔가며 테스트하면 귀찮을 수 있으니

https://regexr.com/

사이트를 참고해서 만들 수 있도록 하면 편합니다.
