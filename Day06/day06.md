# 객체 지향 프로그래밍

### 객체 지향 프로그래밍의 장점

- 보안성 향상
- 소프트웨어의 생산성 향상
- 실세계에 대한 쉬운 모델링

등이 있습니다. 지금 당장은 알아도 크게 와닿는 부분이 없으니 그렇구나하고 넘어갑시다. 아래의 설명을 보면 자연스레 이해할 수 있습니다.

### 객체

프로그래밍 관련 언어라 어려운 개념 아닐까 생각되는데 실제로는 그렇지 않습니다.

넓은 의미로는 실생활에서의 사물입니다.

지금 당장에 보이는 컴퓨터, 핸드폰 심지어는 강아지, 고양이 같은 생물도 될 수 있겠네요.

또한 우리의 사물에는 특징과 동작도 있습니다.

강아지로 예를 들자면 특징에는 다리 개수, 털 색깔 등이 있겠고 동작에는 짖기, 물기 그리고 꼬리 흔들기 등이 있겠네요

이러한 사물 즉, 객체의 특성을 프로그래밍으로 옮기는 것이 객체 지향 프로그래밍입니다.

저희 교수님의 설명을 인용하자면

> 객체 지향 프로그래밍은 실생활을 그대로 프로그래밍에 투영하기 위한 것이다.

라고 하셨습니다.

### 클래스 / 인스턴스

- 클래스 :

  객체를 표현할 수 있도록 필드(변수)와 메서드(함수)를 정의함으로써 객체를 일반화합니다.
  여기서 필드는 위에서 말한 특징이 되겠고 메서드는 동작이 되겠습니다.

  일종의 설계도라고 보시면 됩니다.

  필드와 메서드는 자바에서의 표현이라 자바스크립트와 차이가 있을 수 있습니다.

- 인스턴스 :

  만들어진 클래스를 통해 메모리에 할당된 데이터(설계도를 통해 만들어진 제품)입니다.

### 객체 지향 프로그래밍의 특징

1. **추상화**
   - 객체들의 공통적인 속성을 도출하는 것
   - 클래스를 정의하는 부분에서 추상화라고 할 수 있습니다.
2. **상속**

   - 하나의 클래스가 가진 특성을 다른 클래스가 물려받아 사용할 수 있습니다.
   - 기존의 코드를 재사용할 수 있습니다.

3. **다형성**
   - 동일한 이름의 함수를 각각의 클래스에 맞게 재구성할 수 있습니다.
     - 오버라이딩 : 부모클래스의 메서드와 같은 이름을 사용하되 내용을 달리하는 것
     - 오버로딩 : 같은 이름의 함수를 여러개 정의하고 매개변수에 따라 동작을 달리하는 것.
4. **캡슐화**
   - 실제 데이터를 외부에 드러나지 않도록 해서 정보를 은닉할 수 있습니다.
   - 데이터에 접근하기 위해서 메서드를 사용합니다. 이를 통해 잘못된 값의 접근을 사전에 막아 원인 모를 오류를 방지할 수 있습니다.

# JS에서의 객체 지향

### 프로퍼티, 메서드

자바스크립트에서는 객체를 키와 값으로 구성된 프로퍼티의 집합이라는 표현을 씁니다.

- 프로퍼티 :

  객체를 구성하는 요소 값

- 메서드:

  프로퍼티 값 중 그 형태가 함수인 것.

  의미적으로 보면 프로퍼티는 속성이고, 메서드는 동작이라고 보면 됩니다.

- 그렇다면 함수와 메서드의 차이는?

  함수는 그 자체로 객체인 것입니다. 프로퍼티는 객체에 종속되어 객체를 동작하는 함수라고 보면 됩니다.

### 프로토타입

JS에서는 클래스라는 개념을 사용하지 않습니다. ES6문법에서 추가된 클래스는 사실 다른 방법을 사용해 객체의 개념을 만들어내는 것이죠

그 때 사용하는 것이 바로 프로토타입입니다.

프로토타입은 상속의 개념을 가지지 않습니다. 연결이라는 표현을 쓰고 이것이 프로토체이닝이라는 개념을 나타내게 되는 것이죠.

```
function Person(name, age){
  this.name = name;
  this.age = age
}
```

위와 같이 함수를 정의합니다.

이 때 내부적으로는 이러한 과정이 펼쳐집니다.

![Alt text](%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C1.JPG)

Person함수가 정의되고 그 안에 prototype이 Person의 프로토타입 객체를 가르키게 되고 프로토타입 객체의 constructor는 다시 Person 함수를 가르키는 상호참조의 관계를 가집니다.

```
const hong = new Person('홍길동', 20);
```

위와 같이 새로운 객체를 생성하면

![Alt text](%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C2.JPG)

새로운 hong 이라는 객체가 생성되고 hong 객체 안에 **proto**는 다시 Person의 프로토타입 객체를 가르키게 됩니다.

다시 말씀드리지만 JS에는 클래스가 없습니다. 사람들에게 익숙한 클래스라는 이름으로 비슷한 기능을 프로토타입이 대신해주고 있는 것이죠.

위의 모든 내용은 모두 객체입니다.(원시 타입 빼고) 클래스는 없습니다.

```
Person.prototype.sayHello = function(){console.log(`안녕 난 ${this.name} ${this.age}살이야`)}
```

위와 같이 프로토타입에 새로운 함수를 할당할 수 있습니다.
![Alt text](%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C3.JPG)

```
hong.sayHello();
//안녕 난 홍길동 20살이야
```

hong에 sayHello()가 없다면 내부적으로는 **proto**를 이용해 연결된 객체로 이동해서 sayHello()가 있는지 탐색합니다.

탐색 결과 존재한다면 그대로 실행하고 없다면 undefined를 내고 끝나게 되죠

우리는 이걸 봤을 때 인스턴스의 개념과 동일 시 하며 보는 것입니다. 사실 인스턴스는 아닙니다. 클래스의 내용을 복사해서 집어넣는 식이 아닌 **proto**를 사용해 연결된 객체를 참조하는 것 뿐이죠.

상속 또한 비슷하게 복사가 아닌 연결된 객체를 참조하는 식으로 이루어집니다.

```
const ko = new Person('고길동', 22);
ko.sayHello();
//안녕 난 고길동 22살이야
```

그렇기 때문에 프로토타입에 연결된 모든 객체는 sayHello()를 사용할 수 있는 것 입니다.
![Alt text](%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%93%9C4.JPG)

이러한 구조는 클래스를 생성해서 인스턴스 내부에 함수를 다 생성해줘야하는 방식과 달리 함수 저장은 프로토타입에 하나만 되기 때문에 메모리적으로 이점을 가져옵니다.
